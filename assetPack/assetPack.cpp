#include <shlwapi.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string>

#define STB_SPRINTF_IMPLEMENTATION
#include "../engine/zorro/stb_sprintf.h"

/***************************************************************************************************/
inline char* strlcpy(char* dst, const char* src, size_t size) noexcept;

[[noreturn]] static void __panic(const char* file, int line, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);

    char buffer[1024];
    stbsp_vsnprintf(buffer, sizeof(buffer), fmt, args);
    va_end(args);

    char filename[260];
    strlcpy(filename, file, sizeof(filename));
    PathStripPathA(filename);
    fprintf(stderr, "[%s:%d] %s\n", filename, line, buffer);
    abort();
}

#define panic(...) __panic(__FILE__, __LINE__, __VA_ARGS__)

inline char* strlcpy(char* dst, const char* src, size_t size) noexcept
{
    auto srclen = strlen(src);
    if (size == 0 || srclen >= size)
    {
        panic("strlcpy failed. Need %zu bytes but %zu are available", srclen, size);
    }
    memcpy(dst, src, srclen + 1);
    return dst;
}

inline char* strlcat(char* dst, const char* src, size_t size) noexcept
{
    auto dstlen = strlen(dst);
    auto srclen = strlen(src);
    if (dstlen + srclen + 1 > size)
    {
        panic("strlcat failed. Need %zu bytes but %zu are available", dstlen + srclen + 1, size);
    }
    memcpy(dst + dstlen, src, srclen + 1);
    return dst;
}

/***************************************************************************************************/
class File
{
public:
    File(const char* filename, const char* mode);
    File();
    File(File&&) = delete;
    File(const File&) = delete;
    File& operator=(File&&) = delete;
    File& operator=(const File&) = delete;
    ~File();

    void open(const char* filename, const char* mode);
    void close();
    void printf(const char* fmt, ...);
    int read(void* buffer, int size);

private:
    FILE* _file;
    std::string _filename;
};

/***************************************************************************************************/
File::File(const char* filename, const char* mode)
    : _file(nullptr)
{
    open(filename, mode);
}

File::File()
    : _file(nullptr)
{
}

File::~File()
{
    close();
}

void File::open(const char* filename, const char* mode)
{
    close();
    _filename = filename;

    _file = fopen(filename, mode);
    if (!_file)
    {
        panic("Error opening %s", filename);
    }
}

void File::close()
{
    if (_file)
    {
        if (fclose(_file))
        {
            panic("Error while closing %s", _filename.c_str());
        }
    }
}

void File::printf(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    if (vfprintf(_file, fmt, args) < 0)
    {
        panic("Error writing to %s", _filename.c_str());
    }
    va_end(args);
}

int File::read(void* buffer, int size)
{
    auto ret = fread(buffer, 1, size, _file);
    if (ret == -1)
    {
        panic("Error while reading from %s", _filename.c_str());
    }
    return ret;
}

/***************************************************************************************************/
int main(int argc, char** argv)
{
    if (argc < 2)
    {
        fprintf(stderr, "Usage: %s <outfile> <infile1>...[infileN]\n", argv[0]);
        return 1;
    }

    File outf;
    outf.open(argv[1], "wt");
    outf.printf("#pragma once\n");
    outf.printf("\n");
    outf.printf("/* Autogenerated file, do not edit manually */\n\n");
    outf.printf("struct ZorroAsset\n");
    outf.printf("{\n");
    outf.printf("    const char* name;\n");
    outf.printf("    int size;\n");
    outf.printf("    const unsigned char* data;\n");
    outf.printf("};\n");
    outf.printf("\n");

    for (int i = 2; i < argc; i++)
    {
        outf.printf("const unsigned char zorroAsset%x[] =\n", i);
        outf.printf("{\n");

        size_t size = 0;
        char buffer[512];
        File inf(argv[i], "rb");
        int col = 0;
        outf.printf("    ");
        while (true)
        {
            auto readCount = inf.read(buffer, sizeof(buffer));
            if (!readCount)
            {
                break;
            }
            size += readCount;

            for (int j = 0; j < readCount; j++)
            {
                if (col > 20)
                {
                    outf.printf("\n    ");
                    col = 0;
                }
                outf.printf("0x%02X, ", buffer[j] & 0xFF);
                col++;
            }
        }

        outf.printf("\n");
        outf.printf("};\n");
        outf.printf("\n");
        outf.printf("const int zorroAsset%xSize = 0x%08zX;\n", i, size);
        outf.printf("\n");
    }

    outf.printf("const ZorroAsset zorroAssets[] =\n");
    outf.printf("{\n");

    for (int i = 2; i < argc; i++)
    {
        char name[1024];
        strlcpy(name, argv[i], sizeof(name));
        PathStripPathA(name);
        outf.printf("    { \"%s\", zorroAsset%xSize, zorroAsset%x },\n", name, i, i);
    }

    outf.printf("};\n");
    outf.printf("\n");
    return 0;
}

